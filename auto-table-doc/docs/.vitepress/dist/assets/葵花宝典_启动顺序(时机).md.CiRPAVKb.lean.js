import{_ as e,c as t,a2 as o,o as l}from"./chunks/framework.DVcYaelC.js";const p=JSON.parse('{"title":"常见问题","description":null,"frontmatter":{"title":"常见问题","description":null},"headers":[],"relativePath":"葵花宝典/启动顺序(时机).md","filePath":"葵花宝典/启动顺序(时机).md","lastUpdated":1742205971000}'),r={name:"葵花宝典/启动顺序(时机).md"};function n(i,a,u,s,d,c){return l(),t("div",null,a[0]||(a[0]=[o('<h2 id="autotable启动顺序-时机" tabindex="-1">AutoTable启动顺序/时机 <a class="header-anchor" href="#autotable启动顺序-时机" aria-label="Permalink to &quot;AutoTable启动顺序/时机&quot;">​</a></h2><h3 id="需求" tabindex="-1">需求 <a class="header-anchor" href="#需求" aria-label="Permalink to &quot;需求&quot;">​</a></h3><p>系统启动的时候，有初始化相关的操作（比如某些同学喜欢在@PostConstruct写一些操作数据库的初始化逻辑），因为AutoTable是通过实现spring的CommandLineRunner接口启动的，所以AutoTable的执行顺序晚于业务逻辑的执行顺序，进而导致AutoTable没有来得及改表，逻辑就先执行了，然后报错了。</p><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><blockquote><p>改变业务逻辑的触发时机</p></blockquote><ol><li>监听spring的ApplicationReadyEvent事件。</li><li>实现ApplicationRunner接口或者CommandLineRunner接口，然后接口指定@Order(值小于Ordered.LOWEST_PRECEDENCE即可)。</li><li>实现AutoTableFinishCallback接口，在AutoTable执行完之后，执行回调逻辑。</li></ol><blockquote><p>改变AutoTable的执行时机</p></blockquote><ol start="4"><li>不使用spring boot的快速集成方案@EnableAutoTable，改为手动触发AutoTable的执行逻辑，参考<a href="/指南/基础/快速上手.html#第-3-步-激活autotable">快速上手 - 普通java</a></li></ol>',8)]))}const h=e(r,[["render",n]]);export{p as __pageData,h as default};
