import{_ as e,c as t,a2 as r,o as l}from"./chunks/framework.DVcYaelC.js";const _=JSON.parse('{"title":"葵花宝典","description":null,"frontmatter":{"title":"葵花宝典","description":null},"headers":[],"relativePath":"葵花宝典/父类字段没有创建.md","filePath":"葵花宝典/父类字段没有创建.md","lastUpdated":1749533101000}'),i={name:"葵花宝典/父类字段没有创建.md"};function o(n,a,s,d,c,p){return l(),t("div",null,a[0]||(a[0]=[r('<h2 id="父类字段没有自动创建" tabindex="-1">父类字段没有自动创建 <a class="header-anchor" href="#父类字段没有自动创建" aria-label="Permalink to &quot;父类字段没有自动创建&quot;">​</a></h2><h3 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h3><p>子类继承了父类，但是父类中的字段没有在子类的表中自动创建列</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>最初对父类字段的处理方式是通过getDeclaredFields方法，获取了全部字段，仅剔除了static和final修饰的字段。</p><p>后续有小伙伴反馈，在使用部分框架（比如MybatisFlex）的时候，使用它的基类，会错误的将内部的私有字段在表中创建了列，不符合继承的原则。</p><p>所以，自<a href="/变更日志.html#_1-8-1">1.8.1</a>开始，修改了子类对父类字段的继承规则，仅支持public和protected修饰的字段，作为可被继承的字段。</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>自<a href="/变更日志.html#_1-8-4">1.8.4</a>开始，新增了一个<a href="/配置.html#strict-extends">strictExtends</a>配置开关，默认开启。</p><p>表示：子类继承父类的字段是否开启严格继承的模式（只继承public、protected修饰的字段）。</p>',10)]))}const u=e(i,[["render",o]]);export{_ as __pageData,u as default};
